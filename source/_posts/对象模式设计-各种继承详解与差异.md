---
title: 对象模式设计-各种继承详解与差异
catalog: true
date: 2022-11-02 10:30
subtitle: javascript权威指南第六章对象篇
lang: cn
header-img: /img/header_img/lml_bg.jpg
tags:
 - js对象
categories:
 - javascript
---
# 各种继承详解与差异
补充：instanceof   用于检测构造函数的prototype是否存在于这个实例对象的原型链上实例对象 instanceof  构造函数
<br/>


 #### 原型链继承
将父类型的实例赋值给要继承的对象的原型对象，子原型对象拿到父实例中所有属性和方法，摒弃原本的原型对象，新建出一个原型对象指向了父实例的原型对象。新建原型对象的constructor指向了实例的构造函数。新建原型对象可以通过原型链找到实例原型对象上的属性和方法
```javascript
    function SuperType() {
        this.property = true;
      }
      SuperType.prototype.getSuperValues = function () {
        console.log(this.property);
      };
      function SubType() {
        this.subProperty = false;
      }
      SubType.prototype.getSubValues = function () {
        console.log(this.subProperty);
      };
      SubType.prototype=new SuperType()
      let instance=new SubType()
      instance.getSuperValues()//true

     //getSubValues是SubType旧原型对象上的方法，当等于SuperType实例之后
      //开辟了一个新的原型对象，现在实例instance指向了
      //新的原型对象，是找不到getSubValues方法的
     instance.getSubValues()//error  

      console.log(instance.subProperty);//false 子类型的实例属性还是可以拿到的

      //旧的SubType对象的constructor指向构造函数SubType
      //继承SuperType实例之后，新的SubType对象的constructor指向构造函数SuperType
     console.log(SubType.prototype.constructor==SuperType)//true

      //SupertType的原型对象通过隐式属性__proto__指向了Object的原型对象
      //Array,String这些原生对象上的方法都是通过这个方法找到的
     console.log(SuperType.prototype.__proto__==Object.prototype)//true

     //确定原型与实例的关系
     //由于原型链的关系，可以说实例instance是Object、SupertType、SubType任何
     //一个类型的实例 
     //instanceof 前面是一个对象，后面一定要是一个函数或者构造器，
     //如果返回为ture则代表这个对象的___proto___指向了函数的原型对象
     console.log(instance instanceof SubType)//true
     console.log(instance instanceof SuperType)//true
     console.log(instance instanceof Object)//true

```
 以上面的例子为例，要找到getSuperValues方法，原型链的搜索机制为：
  1. 搜索实例instance
  2. 搜索SubType.prototype（新的SubType原型对象）
  3. 搜索SuperType.prototype
在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下

<br/>

**如果想要使用子构造函数的原型对象上的方法,定义方法要在继承之后**
```javascript
  function SuperType(){
       this.prototype=true
     }
     SuperType.prototype.getSuperVal=function(){
       console.log(this.prototype)
     }
     function SubType(){
       this.prototype=false
     }
     let supertInstance=new SuperType()
     SubType.prototype=supertInstance
    //  添加方法
     SubType.prototype.getSubVal=function(){
       console.log(this.prototype)
     }
     //重写超类型中的方法
     SubType.prototype.getSuperVal=function(){
       console.log(this.prototype)
     }
     let instance=new SubType()
     instance.getSubVal() //false
     instance.getSuperVal()//false

    //但是超类型中的方法没有被子类型的重构改变
     supertInstance.getSuperVal()//true

```
<br/>

**原型链继承的缺点**
从超类型那里继承到的实例属性都会变成子类原型对象上的共享属性，这样子引用对象都会变成共享对象，就会造成互相影响。
```javascript
   function SuperColor(){
      this.colorArr=["red","yellow"]  
    }
    
    function SubColor(){}
    SubColor.prototype=new SuperColor()

    let color1=new SubColor()
    //从超类型实例继承而来的colorArr会变成子类原型对象上的共享对象
    color1.colorArr.push("green")
    console.log(color1.colorArr)//['red', 'yellow', 'green']
    let color2=new SubColor()
    //会被互相影响
    console.log(color2.colorArr)//['red', 'yellow', 'green']


    let superColor1=new SuperColor()
    superColor1.colorArr.push("green")
    console.log(superColor1.colorArr)//['red', 'yellow', 'green']
    let superColor2=new SuperColor()
    //colorArr是超类型的实例属性，
    //每次实例化都会给这个对象添加一个colorArr副本，不会互相影响
    console.log(superColor2.colorArr)//['red', 'yellow']

```
<br/>

#### 借用构造函数 也叫伪造对象和经典继承
  通过在子类型构造函数的内部调用超类型构造函数实现。
  
  

 **函数只不过是在特定环境中执行代码的对象，可以通过使用apply或者call方法在新创建的对象上执行构造函数**
```javascript
    function SuperType(){
      this.colorArr=["red","yellow"]
      }
    function SubType(){
      SuperType.call(this)
    }
   //在新创建的SubType实例的环境下调用了SuperType的构造函数。
   //相当于会在新SubType对象上执行SuperType函数中定义的所有对象初始化代码
   //这样子每个SubType的实例都会有自己的colorArr属性副本
    let color1=new SubType()
    color1.colorArr.push("green")
    console.log(color1.colorArr)//['red', 'yellow', 'green']
    let color2=new SubType()
    console.log(color2.colorArr)//['red', 'yellow']

```
**优势**
可以传递参数、每个实例的属性都会创建一个副本，对用引用对象不会互相影响
<br/>

**缺点**
每次实例化都会把属性方法创建一份副本其实是一把双刃剑，每个实例都有一份独立的方法副本会造成内存浪费，方法应该要共享
```javascript
   function SuperPerson(name){
      this.name=name
      this.sayName=function(){
        console.log(this.name)
      }
    }
    function SubPerson(name,age){
     SuperPerson.call(this,name)
     //添加子类型属性，写在调用超类型构造函数后。否则被父类型覆盖
     this.age=age
    }

    //可以向超类型传参
    let person1=new SubPerson("LuLu",29)
    person1.sayName() //LuLu
    console.log(person1.age)//29
    let person2=new SubPerson("Lily",28)
    person2.sayName() //Lily

   //无法通过原型指针找到超类型构造函数,无法识别继承的是哪个对象
    console.log(person1 instanceof SuperPerson)//false

```
<br/>

#### 组合继承
1. 需要传参的私有属性与引用对象在超类构造函数中定义，通过借用构造函数继承，这样子每个实例上的对应属性会有一份属性副本。
2. 共享属性与方法通过原型模式创建，通过原型链继承，节约内存。
3. 创建的实例因为有通过原型链继承，可以识别继承于哪个超类型的对象。
组合继承避免了原型链与借用构造函数的缺陷，融合优点。

```javascript
   function SuperType(name){
      this.name=name
      this.colorsArr=["red","yellow"]
    }
    SuperType.prototype.sayName=function(){
      console.log(this.name)
    }
    function SubType(name,age){
      SuperType.call(this,name)
      this.age=age
    }
    SubType.prototype=new SuperType()
    SubType.prototype.sayAge=function(){
      console.log(this.age)
    }
    let person1=new SubType("LuLu",29)
    person1.colorsArr.push("green")
    console.log(person1.colorsArr)//["red","yellow","green"]
    person1.sayName()//"LuLu"
    person1.sayAge()//29

    let person2=new SubType("bibi",27)
    //colorsArr是实例属性会拷贝出一份属于person2实例的副本，不会受person1影响
    console.log(person2.colorsArr)//["red","yellow"]
    person2.sayName()//"bibi"
    person2.sayAge()//27
    
    //两个实例方法都会指向SuperType的原型对象中的sayName方法
    console.log(person1.sayName==person2.sayName)//true

    //通过原型连继承可以判断出是否继承与哪个构造函数，识别出对象
    console.log(person1 instanceof SubType)//true
    console.log(person1 instanceof SuperType)//true

```
**组合继承的缺点:**
 组合继承无论什么情况下都会调用两次超类型构造函数，超类型构造函数中的属性会被继承两次。
   第一次是在子类型原型继承超类型实例的时候，属性会被记在子类型的原型中。第二次是在子构造函数中调用父构造函数时，在继承一遍父构造函数中的实例属性。
    所以父类构造函数的属性会被子类原型继承一遍，子类实例再继承一遍（子类实例会重写掉子类原型上的属性，因为是后调用）
```javascript
    function SuperType(name){
      this.name=name
      this.colorsArr=["red","yellow"]
    }
    SuperType.prototype.sayName=function(){
      console.log(this.name)
    }
    function SubType(name,age){
      //第二次调用父类构造函数，继承实例属性到SubType实例上
      //因为是后调用，SubType原型对象上的name和colorsArr会被重写，且被屏蔽
      //这时候SubType原型对象上有name和colorsArr属性，SubType上也有
      //name和colorsArr属性
      SuperType.call(this,name)
      this.age=age
    }
    //第一次调用父类构造函数，继承实例属性到SubType原型对象上
    SubType.prototype=new SuperType()
    SubType.prototype.sayAge=function(){
      console.log(this.age)
    }

```
<br/>

#### 原型式继承
设计思想：
如果只是想让一个对象与另一个对象保持类似可以使用原型式继承。
先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。

```javascript
   function object(o){
      function F(){}
      F.prototype=o
      return new F()
    }
    let person={
      name:"LuLu",
      age:29
    }
    let person1=object(person)
    console.log(person1.name) //"LuLu"
    console.log(person1.age)//29

```
从本质上讲，object（）对传入其中的对象执行了一次浅拷贝
**Object.create规范了原型式继承,就相当于是例子中的object方法**
```javascript
    let person={
      name:"LuLu",
      age:29
    }
    let person1=Object.create(person)
    console.log(person1.name) //"LuLu"
    console.log(person1.age)//29
```
缺点：
其实原型式继承的本质是把一个函数的原型对象赋值给要创建的那个对象（新创建的对象的__proto__指向了被创建函数的prototype），所以引用类型还是会有共享值得情况。
**Object.create创建的对象会存在引用对象共享值得情况。并且没有办法继承到父类的实例属性和实例方法。**
```javascript
    let person={
      colorArr:["red","yellow"]
    }
    let person1=Object.create(person)
    person1.colorArr.push("green")
    console.log(person1.colorArr)//['red', 'yellow', 'green']

    let person2=Object.create(person)
    console.log(person2.colorArr)//['red', 'yellow', 'green']

```
<br/>

#### 寄生继承
寄生继承与原型继承相类似：
原型继承复制一个对象到构造函数的原型对象上。然后返回实例。
寄生继承通过Object复制一个仅用于封装继承过程的函数，在函数内部以某种方式来增强对象，最后返回对象
```javascript
    function createFunc(original){
    //通过Object复制一个对象，不是一定要用Object的，其他可以复制对象的都可以用
      var clone=Object(original)
    //给对象添加方法
      clone.sayName=function(){
        console.log(this.name)
      }
      return clone
    }
    let person={
      name:"bibi"
    }
    let person1=createFunc(person)
    person1.sayName()

```
<br/>

#### 寄生组合继承
针对于组合继承中父类的实例属性会生成两份的情况，寄生组合其实就是拷贝一份父类原型给到子类，子类不再通过父类构造函数获得从而子类原型上不会再有父类实例属性。
**借用构造是有call和apply方法不变，原型继承从继承父类构造函数变成继承父类原型对象**
```javascript
   function SuperType(name){
      this.name=name
      this.colorsArr=["red","yellow"]
    }
    SuperType.prototype.sayName=function(){
      console.log(this.name)
    }
    function SubType(name,age){
      SuperType.call(this,name)
      this.age=age
    }
    inheritPrototype(SubType,SuperType)

    SubType.prototype.sayAge=function(){
      console.log(this.age)
    }
    let person1=new SubType("Lulu",28)
    person1.sayName()
    person1.sayAge()
   
     //函数变量提升可以放在调用之后定义
    function inheritPrototype(subType,superType){
     //拷贝一份父类原型副本赋值给子类原型，实现继承
     //原本的object()方法已经被废弃，所以现在使用的Object方法。
     //但是使用Object方法相当于父类原型对象赋值给子类原型对象，
     //父类的原型对象会被子类原型对象所影响
      subType.prototype=Object(superType.prototype)
    }

```
<br/>

#### 原型组合继承(最佳方案)
**原型链继承不可以直接赋值，父类的原型对象会被子类原型对象所影响**
```javascript
      function SuperType() {}
        SuperType.prototype.getVal = function () {
        return true;
      };
      function SubType() {}
      //如果使用寄生继承，object()已经被废弃，现在只有Object()方法，
      //但是Object()方法与直接去赋值问题相同，父类原型对象会被子类原型对象所影响
      //  SubType.prototype = Object(SuperType.prototype);
       SubType.prototype = SuperType.prototype;
       SubType.prototype.setVal = function () {
        return false;
      };
      console.log(SuperType.prototype);
      //{getVal: ƒ, setVal: ƒ, constructor: ƒ}
```
基于寄生组合继承与组合继承的缺点，通过原型组合继承去规避问题
  **使用原型组合继承的方式，通过Object.create方法，**子类原型对象可以通过隐式属性__proto__指向父类的原型对象，且子类原型对象不会影响到父类原型对象。
  <br/>
  
精华部分：
```javascript
       function inheritPrototype(subType, superType) {
        //比起寄生用的Object() 拷贝，Object.create可以做到子类不影响父类
        //比起原型链的继承父类构造函数的实例，可以避免多一次的函数调用
        subType.prototype = Object.create(superType.prototype);
      }
```
完整代码:
```javascript
    function SuperType(name) {
        this.name = name;
        this.colorsArr = ["red", "yellow"];
      }
      SuperType.prototype.sayName = function () {
        console.log(this.name);
      };
      function SubType(name, age) {
        SuperType.call(this, name);
        this.age = age;
      }
      inheritPrototype(SubType, SuperType);

      SubType.prototype.sayAge = function () {
        console.log(this.age);
      };
      let person1 = new SubType("Lulu", 28);
      person1.sayName();
      person1.sayAge(); //函数变量提升可以放在调用之后定义
      function inheritPrototype(subType, superType) {
        //比起寄生用的Object() 拷贝，Object.create可以做到子类不影响父类
        //比起原型链的继承父类构造函数的实例，可以避免多一次的函数调用
        subType.prototype = Object.create(superType.prototype);
       //保证构造器的一致性，constructor指向subType
        subType.prototype.constructor = subType;
     }

      //子类SubType的原型对象的隐式属性指向了父类原型对象。
      //子类原型对象既可以添加方法，公共属性也可以完全不影响父类原型对象。
      console.log(SubType.prototype.__proto__ == SuperType.prototype); //true
      console.log(SubType.prototype instanceof SuperType); //true

      //子类添加的sayAge方法并没有添加到父类原型对象中
      console.log(SuperType.prototype); //{sayName: ƒ, constructor: ƒ}
      console.log(SubType.prototype.constructor);//function Subtype(){ }

```