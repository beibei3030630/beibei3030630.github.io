---
title: 对象模式设计-各种对象模式详解与差异
catalog: true
date: 2020-10-25 18:00
subtitle: javascript权威指南第六章对象篇
lang: cn
header-img: /img/header_img/lml_bg.jpg
tags:
 - js对象
categories:
 - javascript
---


# 各种对象模式详解与差异
  **设计对象模式的意义**
  所需要的实例对象通过构造函数获得私有属性、通过原型链获得共享的属性。

  
  *什么是好的方式？*
  私有属性通过构造函数的方式获得（不考虑实例中自定义私有属性）且不需要重写，共
  享属性通过原型链找到且不需要重复创建。

> 资料：  [创建对象、对象继承的实用方式及理解](https://segmentfault.com/a/1190000004559437)

 #### 工厂模式
```javascript
 // 在函数内创建一个对象，能够根据接收的参数来构建一个包含所有必要信息的Person对象
   function createPerson(name, age) {
        let Person = new Object();
        Person.name = name;
        Person.age = age;
         return Person;
      }
      let person1 = createPerson("Lily", 29);
      let person2 = createPerson("Ming", 28);
      console.log(person1.name + person1.age);
      console.log(person2.name + person2.age);
```
工厂模式解决了创建多个相似对象的问题。
缺点：没有解决对象识别的问题（无法知道对象的类型）
```javascript
    console.log(person1 instanceof Object); //true
    console.log(person1 instanceof createPerson); //false
```
<br/>

 #### 构造函数
优点:可以将构造函数的实例表示为一种特定类型
```javascript
    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.sayName = function () {
          console.log(this.name);
        };
      }
      let person1 = new Person("Lily", 29);
      person1.sayName();
```
优点:可以将构造函数的实例表示为一种特定类型
```javascript
   console.log(person1 instanceof Object); //true
   console.log(person1 instanceof Person); //true

```

构造函数的用法：
构造函数与其他函数的区别**只是调用的方式不同**。
   1.当做构造函数使用
   \***所有函数，只要调用的时候通过new操作符来调用，就可以作为构造函数。否则就是普通函数。**
```javascript
    let person1 = new Person("Lily", 29);
    person1.sayName();
```

   2.当做普通函数调用
   \***当在全局作用域中调用一个函数，this对象指向window。window对象下就会拥有调用的那个函数的所有属性与方法。**所以在这里window对象就会有sayName方法
```javascript
    Person("lulu", 30);  
    window.sayName(); //"lulu"   
```

   3.在另一个对象的作用域中调用
```javascript
     let o = new Object();  
     Person.call(o, "bobo", 30);   
     o.sayName();   

```
new一个构造函数，如果构造函数没有返回值，会隐式的把this作为返回值
<br/>
##### **new一个构造函数的本质**

**如果构造函数没有返回值，会先创建一个指向构造函数原型对象的空对象，this会作为一个默认的返回值，在js底层进行隐式转换的时候，空对象会作为执行环境,this将会作为传参**

    **let person=new Person()        ==        new Person().apply(person,this)**
    *有点类似于上面这种，个人理解不一定对*

**从而生成一个拥有构造函数属性同时\_\_proto\_\_又指向了构造函数.prototype的新对象**
```javascript
 function Person(name, age) {
          this.name = name;
          this.age = age;
          this.sayName = function () {
            console.log(this.name);
          };
        }
        //第一步 先创建了一个指向Person.prototype的空对象
        //第二步 构造函数没有Person，所以默认返回值为this
        //第三部 js底层通过call或者是apply改变this的运行环境作用域（为新对象person）
       //从而生成一个拥有构造函数属性又同时指向构造函数原型对象的新对象
        let person = new Person("Lily", 29);
```

**如果构造函数有返回值，返回的是对象（不包括null）和函数，则返回值为对象，否则返回的还是默认的this对象**

```javascript
    function F() {
        this.a = 37;
      }
      let o = new F();
      console.log(o.a); //37
//********************************************
      function F() {
        this.a = 37;
     //返回对象，则构造函数F的返回值为这个对象
        return {
          a: 38,
        };
      }
      let o = new F();
      console.log(o.a); //38
//************************************************
     function foo() {
        this.b = 100;
        return this.a;
      }
      //foo通过bind传入对象后,在执行对象下变量a有了值
      let func = foo.bind({ a: 100 });
      console.log(func()); //100
      //构造函数foo有return值，所以return值是返回值 this.a等于undefined
      //return undefined 等于foo还是返回了this作为返回值
      console.log(new foo()); //foo {b:100}
//************************************************
//其他例子：
   function fn() {
        this.user = "追梦子";
        return {};
      }
      var a = new fn();
      console.log(a.user); //undefined
//*********************************************
    function fn() {
        this.user = "追梦子";
        return 1;
      }
      var a = new fn();
      console.log(a.user); //追梦子
//*********************************************
   function fn() {
        this.user = "追梦子";
        return function () {};
      }
      var a = new fn();
      console.log(a.user); //undefined

//*********************************************
   function fn() {
        this.user = "追梦子";
        return undefined;
      }
      var a = new fn();
      console.log(a.user); //追梦子
//*********************************************
  function fn() {
        this.user = "追梦子";
        return null;
      }
      var a = new fn();
      console.log(a.user); //追梦子

```
**构造函数缺点**：
在构造函数中创建的每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数是不相等的。
```javascript
     function Person(name) {
        this.name = name;
        this.sayName = function () {
          console.log(this.name);
        };
      }
      let person1 = new Person("BIBI");
      person1.sayName();
      let person2 = new Person("CICI");
      person2.sayName();
      person1.sayName== person2.sayName   //false
    
************************************
      this.sayName = function () {
          console.log(this.name);
        };
  //等价于
  this.sayName = new Function(console.log(this.name));

```
 解决多次创造函数实例的办法：把函数定义转移到构造函数外部。
```javascript
      function Person(name) {
        this.name = name;
        this.sayName = sayName;
      }
      function sayName() {
        console.log(this.name);
      }

      let person1 = new Person("BIBI");
      let person2 = new Person("CICI");
      console.log(person1.sayName == person2.sayName) //true
```
  但是一样有对象如果有多个方法就需要定义多个全局函数的弊端，没有封装性可言。
<br/>
#### **构造函数与工厂模式的区别**
构造函数：
1.没有显示的创建对象

2.直接将属性和方法赋给了this对象

3.没有return语句

4.实例可以标识为一种特定的类型

例如 let person1=new Person(); person1 instanceof Person //true
<br/>
#### **原型模式**

每个函数都有一个prototype属性，（**Function与Object都是js自带函数，所有他们都有prototype**）prototype属性是一个指针，指向了函数的原型对象。**实例对象没有原型对象,Object是因为是js自带的函数所以才有原型对象。**

可以对原型对象设定属性和方法，可以让对象实例进行共享。

优势：对比构造函数来说不必在构造函数中定义对象的实例信息。既不会每次实例化对象都创建一个实例函数也不会为了避免创建多个实例函数而放在全局，从而失去了封装性。

原型模式执行过程：
```javascript
     function Person(name) {
        this.name = name;
      }
      Person.prototype.sayName = function () {
        console.log(this.name);
      };
      let person1 = new Person("bibi");
      person1.sayName();
    //解析器会解析两次,先搜索实例person1有没有sayName方法，
    //没有的话就会去搜索原型对象上是不是有sayName方法。从而读取到原型对象上的方法

```
 

###### **1.理解原型对象**

+ 每个函数拥有一个原型对象,函数通过prototype找到原型对象。

+ 函数的实例对象通过隐式属性\_\_proto\_\_找到这个原型对象。

+ 原型对象有一个默认属性constructor，指向函数
```javascript
     function Person() {}
      let person1 = new Person();
      //实例对象的__proto__指向原型对象
      console.log(person1.__proto__ == Person.prototype);//true
      //原型对象的默认属性constructor指向函数
      console.log((Person.prototype.constructor == Person));//true
      //原型对象通过__proto__指向Object的原型对象
      console.log(Person.prototype.__proto__ == Object.prototype);//true
      //但是函数不能指向Function的原型对象，因为Person的原型对象和Function的
      //原型对象平行，同时指向Object的原型对象
      console.log(Person.prototype.__proto__ == Function.prototype);//false
      console.log(Function.prototype.__proto__ == Object.prototype);//true

```
 

###### **2.原型模式的搜寻方式**

+ 解析器在寻找属性和方法的时候会优先寻找实例上的属性和方法，如果能找到则不会再去搜寻原型对象。
```javascript
     function Person() {}
      Person.prototype.name = "bibi";

      let person1 = new Person();
      person1.name = "Lily";
      console.log(person1.name);//实例person1上拥有属性name，则不再寻找原型对象

      let person2 = new Person();
      console.log(person2.name);//实例上无属性name，继续搜索原型对象
```

 

###### **3.判断一个属性存在于实例上还是存在于原型对象上**

"属性" in Object ：用来判断 这个属性是否存在于对象上，无论是实例还是原型对象都为true

Object hasOwnProperty("属性"):用来判断属性是否在实例上，在实例上则为true

结合两者:
!object.hasOwnProperty(name) && name in object：判断是否在原型上
```javascript
      function Person(name) {
        this.name = name;
      }
      Person.prototype.age = "27";

      let person1 = new Person("bibi");
      function hasPrototypeProperty(object, name) {
        return !object.hasOwnProperty(name) && name in object;
      }
      console.log(hasPrototypeProperty(person1, "age")); //true
      console.log(hasPrototypeProperty(person1, "name")); //false

```

 

###### **4.获取原型对象上属性的方法**
```javascript
     function Person(name, sex) {
        this.name = name;
        this.sex = sex;
      }
      Person.prototype.age = "27";
      Person.prototype.address = "xx路xx街";
      let person1 = new Person("bibi", "female");

      //传入原型拿到所有原型上可枚举的属性
      console.log(Object.keys(Person.prototype));//['age', 'address']

      //getOwnPropertyNames可以拿到所有不可枚举加可枚举的属性
      console.log(Object.getOwnPropertyNames(Person.prototype));
      //['constructor', 'age', 'address']

      //传入实例拿到所有实例上可枚举的属性
      console.log(Object.keys(person1));//['name', 'sex']

```

 

###### **5.使用字面量方法定义原型对象**

    使用字面量相当于创建了一个新的原型对象，会与原有的原型对象共存，但是要注意创建实例的位置与原型对象的关系。
```javascript
     function Person() {}
      let person1 = new Person();
      //现在有两个原型对象 原先的原型对象，只要一个默认属性constructor
      console.log(Person.prototype); //constructor

      //使用字面量相当于新建了一个原型对象
      Person.prototype = {
        //指定了新原型对象的构造函数指向，不指定就不会再指向构造函数Person了
        constructor: Person,
        name: "cici",
        sayName() {
          console.log(this.name);
        },
      };
      let person2 = new Person();

      //新创建的原型对象，三个默认属性:constructor、name、sayName
      console.log(Person.prototype);
      // 新创建的原型对象指定了constructor指向
      console.log(Person.prototype.constructor == Person); //true

      // person1的实例在新原型对象之前创建，所以person1.__proto__指向了原先的原型对象
      person1.sayName(); //error
      // person2的实例在新原型对象之后创建，所以person2.__proto__指向了新的原型对象
      person2.sayName(); //cici

```

 

###### **6.原型模式的缺点**

原型中的属性都是被共享的，所以实例中修改引用类型的值，同时也会修改掉原型对象中引用类型的值。
```javascript
      function ColorList() {}
      ColorList.prototype.arr = ["red", "yellow"];
      let searchColor1 = new ColorList();
      searchColor1.arr.push("green");
      console.log(searchColor1.arr);//['red', 'yellow', 'green']

      let searchColor2 = new ColorList();
      console.log(searchColor2.arr);//['red', 'yellow', 'green']

```

 <br/>

##### **组合模式（构造函数模式+原型模式）**

 构造模式用于定义实例属性

 原型模式用于定义方法和共享属性（不能是引用类型的属性）

 结果，每个实例都有一份实例属性的副本同时又共享着方法，最大限度的节省内存。另外这种混合模式还支持向构造函数传递参数
```javascript
    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.friends = [];
      }
      Person.prototype = {
        constructor: Person,
        sayPersonInfo() {
          console.log(this.name + this.age + this.friends.join(",     "));
     },
    };
      let person1 = new Person("Lily", 29);
      person1.friends.push("Tom", "Jerry");
      person1.sayPersonInfo(); //Lily29Tom,Jerry

      let person2 = new Person("Mike", 28);
      person2.friends.push("Alice", "Marry");
      person2.sayPersonInfo(); //Mike28Alice,Marry

```

<br/>
 

###### **动态原型**

 1.把所有信息封装在了构造函数中。

 2.通过在构造函数中初始化原型，保持了构造函数和原型的优点。

 换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型

注意：这段代码只会在初次调用构造函数中执行
```javascript
     function Person(name, age) {
        this.name = name;
        this.age = age;
        if (typeof this.sayName != "function") {
          Person.prototype.sayName = function () {
            console.log(this.name);
          };
        }
      }
      let person1 = new Person("Lily", 29);
      person1.sayName();

```
<br/>
 

##### **寄生构造函数模式**

    寄生模式使用new操作符去实例化对象，其余跟工厂模式一致。

    寄生模式也不能识别对象类型，这点也与工厂模式一致。
```javascript
      function SpecialArray() {
        let values = new Array();
        values.push.apply(values, arguments);
        values.toPiepdString = function () {
          return this.join("|");
        };
        return values;
      }
      let colors = SpecialArray("red", "blue", "green");
      console.log(colors.toPiepdString());//red|blue|green
      console.log(colors instanceof SpecialArray); //false

```

 

 使用寄生构造函数的目的是希望扩展原生Array的一个方法toPipeMessage,为了不污染原生构造函数。相当于作者希望通过new去区分，**用寄生构造去定义扩展原生函数，用工厂模式去定义自定义函数。**


> 资料  [js中寄生构造函数模式和工厂模式的区别](https://segmentfault.com/q/1010000004596650)

<br/>

##### **稳妥构造函数模式**
    遵循类似寄生构造函数的模式。稳妥构造函数模式也不能识别对象类型。

    稳妥对象适合在一些安全的环境中（这些环境禁止使用this或者new），或者在防止数据被其他应用程序改动时使用。
```javascript
      function Person(name, age) {
        let o = new Object();
        o.name = name;
        o.age = age;
        o.sayName = function () {
       //第一点不同：创建对象的实例方法不引用this
          console.log(name);
        };
        return o;
      }
      //第二点不同：不适用new操作符调用构造函数
      let person1 = Person("Lily", 29); 
      //person1是个稳妥的对象，除了方法其sayName方法外，
      //没有别的办法可以访问person1里面的其他数据成员
      person1.sayName();

```

 